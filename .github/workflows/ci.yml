name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

env:
  SAPLING_CACHE_VERSION: "3"  # Bump to invalidate cache

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        # Use ubuntu-22.04 because Sapling .deb is built for 22.04
        os: [ubuntu-22.04, macos-latest, windows-latest]
        python-version: ["3.9", "3.11", "3.13"]

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Get latest Sapling release info
        id: sapling-release
        shell: bash
        run: |
          RELEASE_INFO=$(curl -s https://api.github.com/repos/facebook/sapling/releases/latest)
          # Use jq which is available on all GitHub runners
          TAG_NAME=$(echo "$RELEASE_INFO" | jq -r '.tag_name')
          echo "version=$TAG_NAME" >> $GITHUB_OUTPUT
          TAG_ENCODED=$(echo "$TAG_NAME" | sed 's/+/%2B/g')
          echo "version_encoded=$TAG_ENCODED" >> $GITHUB_OUTPUT
          echo "Sapling version: $TAG_NAME"

      # ==================== LINUX ====================
      - name: Cache Sapling deb (Linux)
        if: runner.os == 'Linux'
        id: cache-sapling-linux
        uses: actions/cache@v4
        with:
          path: ~/.cache/sapling
          key: sapling-deb-${{ steps.sapling-release.outputs.version }}-v${{ env.SAPLING_CACHE_VERSION }}

      - name: Download Sapling (Linux)
        if: runner.os == 'Linux' && steps.cache-sapling-linux.outputs.cache-hit != 'true'
        run: |
          SAPLING_VERSION="${{ steps.sapling-release.outputs.version }}"
          SAPLING_VERSION_ENCODED="${{ steps.sapling-release.outputs.version_encoded }}"
          mkdir -p ~/.cache/sapling
          echo "Downloading Sapling $SAPLING_VERSION..."
          curl -L -o ~/.cache/sapling/sapling.deb \
            "https://github.com/facebook/sapling/releases/download/${SAPLING_VERSION_ENCODED}/sapling_${SAPLING_VERSION}_amd64.Ubuntu22.04.deb"

      - name: Install Sapling (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo dpkg -i ~/.cache/sapling/sapling.deb || sudo apt-get install -f -y
          sl --version

      # ==================== macOS ====================
      - name: Install Sapling (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install sapling
          sl --version

      # ==================== WINDOWS ====================
      - name: Cache Sapling (Windows)
        if: runner.os == 'Windows'
        id: cache-sapling-windows
        uses: actions/cache@v4
        with:
          path: C:\sapling
          key: sapling-windows-${{ steps.sapling-release.outputs.version }}-v${{ env.SAPLING_CACHE_VERSION }}

      - name: Install Sapling (Windows)
        if: runner.os == 'Windows' && steps.cache-sapling-windows.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          $SAPLING_VERSION = "${{ steps.sapling-release.outputs.version }}"
          $SAPLING_VERSION_ENCODED = "${{ steps.sapling-release.outputs.version_encoded }}"
          $INSTALL_DIR = "C:\sapling"

          Write-Host "Downloading Sapling $SAPLING_VERSION..."
          $url = "https://github.com/facebook/sapling/releases/download/$SAPLING_VERSION_ENCODED/sapling_windows_${SAPLING_VERSION}_amd64.zip"
          Invoke-WebRequest -Uri $url -OutFile sapling.zip

          New-Item -ItemType Directory -Force -Path $INSTALL_DIR | Out-Null
          Expand-Archive sapling.zip -DestinationPath $INSTALL_DIR -Force

          # Flatten - the zip contains a subdirectory
          $subdir = Get-ChildItem -Path $INSTALL_DIR -Directory | Select-Object -First 1
          if ($subdir) {
            Get-ChildItem -Path $subdir.FullName | Move-Item -Destination $INSTALL_DIR -Force
            Remove-Item $subdir.FullName -Recurse -Force
          }

          Remove-Item sapling.zip -Force

      - name: Setup Sapling PATH (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          echo "C:\sapling" >> $env:GITHUB_PATH
          Remove-Alias -Name sl -Force -Scope Global -ErrorAction SilentlyContinue
          & "C:\sapling\sl.exe" --version

      - name: Remove sl alias (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: Remove-Alias -Name sl -Force -Scope Global -ErrorAction SilentlyContinue

      # ==================== TESTS ====================
      - name: Install test dependencies
        run: pip install pytest

      - name: Debug environment
        shell: bash
        run: |
          echo "=== PATH ==="
          echo $PATH
          echo "=== which sl ==="
          which sl || echo "sl not found"
          echo "=== which git ==="
          which git
          echo "=== Python ==="
          python --version || python3 --version
          echo "=== pytest location ==="
          which pytest
          echo "=== List tests dir ==="
          ls -la tests/

      - name: Run tests
        shell: bash
        working-directory: ${{ github.workspace }}
        run: |
          set +e  # Don't exit on first error - we want to capture all output

          echo "=== Environment Info ===" | tee test_output.log
          echo "RUNNER_OS: $RUNNER_OS" | tee -a test_output.log
          echo "PWD: $(pwd)" | tee -a test_output.log
          echo "Python: $(python --version 2>&1)" | tee -a test_output.log
          echo "Pytest: $(pytest --version 2>&1)" | tee -a test_output.log
          echo "PATH: $PATH" | tee -a test_output.log

          echo "=== Verifying sl is accessible ===" | tee -a test_output.log
          # On Windows, sl.exe is in C:\sapling which should be in PATH
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            echo "Windows detected, checking sl.exe..." | tee -a test_output.log
            ls -la /c/sapling/ 2>&1 | tee -a test_output.log
            /c/sapling/sl.exe --version 2>&1 | tee -a test_output.log
            python -c "import shutil; print('shutil.which sl:', shutil.which('sl'))" 2>&1 | tee -a test_output.log
          else
            echo "which sl:" | tee -a test_output.log
            which sl 2>&1 | tee -a test_output.log
            echo "sl --version:" | tee -a test_output.log
            sl --version 2>&1 | tee -a test_output.log
          fi

          echo "=== Testing sl init directly ===" | tee -a test_output.log
          TEST_DIR="/tmp/test_sl_init_$$"
          mkdir -p "$TEST_DIR"
          echo "Created test dir: $TEST_DIR" | tee -a test_output.log
          cd "$TEST_DIR"
          echo "Running: sl init ." | tee -a test_output.log
          sl init . 2>&1 | tee -a $GITHUB_WORKSPACE/test_output.log
          SL_EXIT=$?
          echo "sl init exit code: $SL_EXIT" | tee -a $GITHUB_WORKSPACE/test_output.log
          echo "Directory contents after sl init:" | tee -a $GITHUB_WORKSPACE/test_output.log
          ls -la 2>&1 | tee -a $GITHUB_WORKSPACE/test_output.log
          cd $GITHUB_WORKSPACE

          echo "=== Testing gitsl.py directly ===" | tee -a test_output.log
          GITSL_DIR="/tmp/test_gitsl_init_$$"
          mkdir -p "$GITSL_DIR"
          echo "Created gitsl test dir: $GITSL_DIR" | tee -a test_output.log
          cd "$GITSL_DIR"
          echo "Running: python $GITHUB_WORKSPACE/gitsl.py init" | tee -a $GITHUB_WORKSPACE/test_output.log
          python $GITHUB_WORKSPACE/gitsl.py init 2>&1 | tee -a $GITHUB_WORKSPACE/test_output.log
          GITSL_EXIT=$?
          echo "gitsl.py init exit code: $GITSL_EXIT" | tee -a $GITHUB_WORKSPACE/test_output.log
          echo "Directory contents after gitsl init:" | tee -a $GITHUB_WORKSPACE/test_output.log
          ls -la 2>&1 | tee -a $GITHUB_WORKSPACE/test_output.log
          cd $GITHUB_WORKSPACE

          echo "=== Running actual tests ===" | tee -a test_output.log
          pytest tests/test_init.py -v --tb=long 2>&1 | tee -a test_output.log
          TEST_RESULT=$?
          echo "Test exit code: $TEST_RESULT" | tee -a test_output.log

          # Now actually fail if tests failed
          exit $TEST_RESULT

      - name: Upload test output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-output-${{ matrix.os }}-${{ matrix.python-version }}
          path: test_output.log

      - name: Show test output as annotation
        if: failure()
        shell: bash
        run: |
          echo "::group::Full test output"
          cat test_output.log
          echo "::endgroup::"
          # Also show as error annotation (first 1000 chars)
          OUTPUT=$(head -c 1000 test_output.log | tr '\n' ' ')
          echo "::error::Test output: $OUTPUT"
