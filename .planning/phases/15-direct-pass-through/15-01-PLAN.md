---
phase: 15-direct-pass-through
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd_show.py
  - cmd_blame.py
  - cmd_rm.py
  - cmd_mv.py
  - cmd_clone.py
  - cmd_grep.py
  - gitsl.py
autonomous: true

must_haves:
  truths:
    - "git show displays current commit information"
    - "git blame shows per-line annotations for a file"
    - "git rm removes tracked files from repository"
    - "git mv renames/moves files in repository"
    - "git clone clones a repository"
    - "git grep searches for patterns in tracked files"
  artifacts:
    - path: "cmd_show.py"
      provides: "git show handler"
      exports: ["handle"]
    - path: "cmd_blame.py"
      provides: "git blame handler"
      exports: ["handle"]
    - path: "cmd_rm.py"
      provides: "git rm handler"
      exports: ["handle"]
    - path: "cmd_mv.py"
      provides: "git mv handler"
      exports: ["handle"]
    - path: "cmd_clone.py"
      provides: "git clone handler"
      exports: ["handle"]
    - path: "cmd_grep.py"
      provides: "git grep handler"
      exports: ["handle"]
    - path: "gitsl.py"
      provides: "dispatch routing for 6 new commands"
      contains: "cmd_show, cmd_blame, cmd_rm, cmd_mv, cmd_clone, cmd_grep"
  key_links:
    - from: "gitsl.py"
      to: "cmd_show.py"
      via: "import and dispatch"
      pattern: 'if parsed.command == "show"'
    - from: "cmd_*.py"
      to: "common.run_sl"
      via: "function call"
      pattern: "run_sl\\("
---

<objective>
Create 6 command handlers for direct pass-through git commands and wire dispatch in gitsl.py.

Purpose: Enable users to run git show, blame, rm, mv, clone, and grep commands against Sapling repositories.
Output: 6 handler files following cmd_diff.py pattern, updated gitsl.py dispatch.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-direct-pass-through/15-RESEARCH.md

# Reference existing handler pattern
@cmd_diff.py
@gitsl.py
@common.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create 6 command handler files</name>
  <files>
    cmd_show.py
    cmd_blame.py
    cmd_rm.py
    cmd_mv.py
    cmd_clone.py
    cmd_grep.py
  </files>
  <action>
Create 6 handler files following the established cmd_diff.py pattern.

**cmd_show.py** (SHOW-01, SHOW-02):
- Import ParsedCommand, run_sl from common
- handle() function returns run_sl(["show"] + parsed.args)
- Simple passthrough - git show and sl show are identical

**cmd_blame.py** (BLAME-01, BLAME-02):
- Import ParsedCommand, run_sl from common
- handle() function returns run_sl(["annotate"] + parsed.args)
- Command name mapping: git blame -> sl annotate (use canonical name, not alias)
- Common flags (-w, -b) pass through directly

**cmd_rm.py** (RM-01, RM-02, RM-03):
- Import ParsedCommand, run_sl from common
- handle() function filters out -r/--recursive flags then calls run_sl(["remove"] + filtered_args)
- IMPORTANT: sl remove is recursive by default, so -r flag must be stripped
- Pattern: filtered_args = [a for a in parsed.args if a not in ('-r', '--recursive')]

**cmd_mv.py** (MV-01, MV-02):
- Import ParsedCommand, run_sl from common
- handle() function returns run_sl(["rename"] + parsed.args)
- Command name mapping: git mv -> sl rename (use canonical name, not alias)

**cmd_clone.py** (CLONE-01, CLONE-02):
- Import ParsedCommand, run_sl from common
- handle() function returns run_sl(["clone"] + parsed.args)
- Simple passthrough - git clone and sl clone are identical

**cmd_grep.py** (GREP-01, GREP-02):
- Import ParsedCommand, run_sl from common
- handle() function returns run_sl(["grep"] + parsed.args)
- Simple passthrough - common flags (-n, -i, -l) are identical
- Note: git -v vs sl -V inversion is a known limitation (documented, not fixed in v1.2)

All handlers should have:
- Module docstring describing the command
- Type hints (ParsedCommand -> int)
- Function docstring with translation notes
  </action>
  <verify>
    All 6 files exist and are syntactically valid:
    python -m py_compile cmd_show.py cmd_blame.py cmd_rm.py cmd_mv.py cmd_clone.py cmd_grep.py
  </verify>
  <done>
    6 handler files exist following cmd_diff.py pattern with correct command translations
  </done>
</task>

<task type="auto">
  <name>Task 2: Update gitsl.py dispatch routing</name>
  <files>gitsl.py</files>
  <action>
Update gitsl.py to import and dispatch to the 6 new handlers.

1. Add imports at top of file (after existing cmd_* imports):
   import cmd_show
   import cmd_blame
   import cmd_rm
   import cmd_mv
   import cmd_clone
   import cmd_grep

2. Add dispatch cases in main() after existing "if parsed.command ==" blocks, before the "Unsupported command handling" section:

   if parsed.command == "show":
       return cmd_show.handle(parsed)

   if parsed.command == "blame":
       return cmd_blame.handle(parsed)

   if parsed.command == "rm":
       return cmd_rm.handle(parsed)

   if parsed.command == "mv":
       return cmd_mv.handle(parsed)

   if parsed.command == "clone":
       return cmd_clone.handle(parsed)

   if parsed.command == "grep":
       return cmd_grep.handle(parsed)

Follow the existing code style exactly (spacing, ordering).
  </action>
  <verify>
    GITSL_DEBUG=1 python gitsl.py show
    GITSL_DEBUG=1 python gitsl.py blame README.md
    GITSL_DEBUG=1 python gitsl.py rm file.txt
    GITSL_DEBUG=1 python gitsl.py mv src dst
    GITSL_DEBUG=1 python gitsl.py clone url
    GITSL_DEBUG=1 python gitsl.py grep pattern

    All should show debug output (not "unsupported command")
  </verify>
  <done>
    gitsl.py routes show, blame, rm, mv, clone, grep to their respective handlers
  </done>
</task>

</tasks>

<verification>
1. All 6 handler files exist and compile without syntax errors
2. gitsl.py imports all 6 new modules without import errors
3. Debug mode (GITSL_DEBUG=1) shows correct routing for all 6 commands
4. No regressions: existing commands (status, log, diff, etc.) still work
</verification>

<success_criteria>
- 6 new cmd_*.py files created following established pattern
- gitsl.py updated with imports and dispatch for 6 commands
- All code is syntactically valid Python
- Commands route correctly (verified via GITSL_DEBUG=1)
</success_criteria>

<output>
After completion, create `.planning/phases/15-direct-pass-through/15-01-SUMMARY.md`
</output>
