---
phase: 26-stash-and-checkout-switch-restore-flags
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - tests/test_stash_flags.py
  - tests/test_switch_flags.py
  - tests/test_restore_flags.py
  - tests/test_checkout_flags.py
autonomous: true

must_haves:
  truths:
    - "Tests verify stash -u includes untracked files"
    - "Tests verify stash -m sets custom message"
    - "Tests verify stash show --stat displays statistics"
    - "Tests verify stash@{n} selects correct stash"
    - "Tests verify stash branch creates branch from stash"
    - "Tests verify switch -C force-creates bookmark"
    - "Tests verify restore -s restores from specific commit"
    - "Tests verify staging area warnings appear"
  artifacts:
    - path: "tests/test_stash_flags.py"
      provides: "E2E tests for STSH-01 through STSH-10"
      min_lines: 150
    - path: "tests/test_switch_flags.py"
      provides: "E2E tests for CHKT-01, CHKT-02, CHKT-07, CHKT-08, CHKT-09"
      min_lines: 80
    - path: "tests/test_restore_flags.py"
      provides: "E2E tests for CHKT-03, CHKT-04, CHKT-10, CHKT-11"
      min_lines: 60
    - path: "tests/test_checkout_flags.py"
      provides: "E2E tests for CHKT-05, CHKT-06"
      min_lines: 30
  key_links:
    - from: "tests/test_stash_flags.py"
      to: "cmd_stash.py"
      via: "run_gitsl calls"
      pattern: 'run_gitsl.*stash'
    - from: "tests/test_switch_flags.py"
      to: "cmd_switch.py"
      via: "run_gitsl calls"
      pattern: 'run_gitsl.*switch'
---

<objective>
Create comprehensive E2E tests for all stash, switch, restore, and checkout flags implemented in Plan 01.

Purpose: Validate that all 21 requirements (STSH-01 through STSH-10, CHKT-01 through CHKT-11) work correctly in real Sapling repositories.

Output: Four new test files covering all flag requirements with passing tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-stash-and-checkout-switch-restore-flags/26-01-SUMMARY.md
@tests/test_stash.py
@tests/test_commit_flags.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_stash_flags.py for STSH-01 through STSH-10</name>
  <files>tests/test_stash_flags.py</files>
  <action>
Create tests/test_stash_flags.py following existing test patterns from test_stash.py and test_commit_flags.py:

```python
"""
E2E tests for git stash flags (STSH-01 through STSH-10).

Tests:
- STSH-01: -u/--include-untracked includes untracked files
- STSH-02: -m/--message sets custom message
- STSH-03: stash show --stat displays statistics
- STSH-04: stash@{n} reference syntax
- STSH-05: -p/--patch interactive mode
- STSH-06: -k/--keep-index warning
- STSH-07: -a/--all includes all files
- STSH-08: -q/--quiet suppresses output
- STSH-09: stash push <pathspec> selective stashing
- STSH-10: stash branch <name> creates branch
"""

import shutil
from pathlib import Path

import pytest

from conftest import run_gitsl
from helpers.commands import run_command


sl_available = shutil.which("sl") is not None
pytestmark = [
    pytest.mark.skipif(not sl_available, reason="Sapling (sl) not installed"),
    pytest.mark.stash_flags,
]


# ============================================================
# STSH-01: -u/--include-untracked
# ============================================================


class TestStashIncludeUntracked:
    """STSH-01: -u/--include-untracked includes untracked files."""

    def test_stash_u_includes_untracked(self, sl_repo_with_commit: Path):
        """git stash -u includes untracked files in stash."""
        # Create untracked file
        untracked = sl_repo_with_commit / "untracked.txt"
        untracked.write_text("untracked content\n")

        # Modify tracked file
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")

        # Stash with -u
        result = run_gitsl(["stash", "-u"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        # Both files should be gone
        assert not untracked.exists()
        status = run_command(["sl", "status"], cwd=sl_repo_with_commit)
        assert "M README.md" not in status.stdout
        assert "? untracked.txt" not in status.stdout

    def test_stash_include_untracked_long(self, sl_repo_with_commit: Path):
        """git stash --include-untracked works same as -u."""
        untracked = sl_repo_with_commit / "untracked.txt"
        untracked.write_text("untracked content\n")

        result = run_gitsl(["stash", "--include-untracked"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        assert not untracked.exists()


# ============================================================
# STSH-02: -m/--message
# ============================================================


class TestStashMessage:
    """STSH-02: -m/--message sets custom message (extended tests)."""

    def test_stash_message_long_form(self, sl_repo_with_commit: Path):
        """git stash --message works."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")

        result = run_gitsl(["stash", "--message", "long form message"],
                          cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        shelves = run_command(["sl", "shelve", "--list"], cwd=sl_repo_with_commit)
        assert "long form message" in shelves.stdout


# ============================================================
# STSH-03: stash show --stat
# ============================================================


class TestStashShow:
    """STSH-03: stash show --stat displays shelve diff statistics."""

    def test_stash_show_stat(self, sl_repo_with_commit: Path):
        """git stash show --stat displays file statistics."""
        # Create and stash changes
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified content for show\n")
        run_command(["sl", "shelve", "-m", "test show"], cwd=sl_repo_with_commit)

        result = run_gitsl(["stash", "show", "--stat"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        assert "README.md" in result.stdout

    def test_stash_show_default(self, sl_repo_with_commit: Path):
        """git stash show without flags shows stat (git default)."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")
        run_command(["sl", "shelve"], cwd=sl_repo_with_commit)

        result = run_gitsl(["stash", "show"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        assert "README.md" in result.stdout

    def test_stash_show_patch(self, sl_repo_with_commit: Path):
        """git stash show -p displays patch."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified content\n")
        run_command(["sl", "shelve"], cwd=sl_repo_with_commit)

        result = run_gitsl(["stash", "show", "-p"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        # Patch output contains diff markers
        assert "diff" in result.stdout or "@@" in result.stdout


# ============================================================
# STSH-04: stash@{n} reference syntax
# ============================================================


class TestStashReference:
    """STSH-04: stash@{n} reference syntax maps to shelve names."""

    def test_stash_ref_zero(self, sl_repo_with_commit: Path):
        """stash@{0} references most recent stash."""
        readme = sl_repo_with_commit / "README.md"

        # Create first stash
        readme.write_text("first\n")
        run_command(["sl", "shelve", "-m", "first stash"], cwd=sl_repo_with_commit)

        # Create second stash
        readme.write_text("second\n")
        run_command(["sl", "shelve", "-m", "second stash"], cwd=sl_repo_with_commit)

        # Show stash@{0} should be most recent (second)
        result = run_gitsl(["stash", "show", "stash@{0}"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

    def test_stash_ref_one(self, sl_repo_with_commit: Path):
        """stash@{1} references second most recent stash."""
        readme = sl_repo_with_commit / "README.md"

        # Create two stashes
        readme.write_text("first\n")
        run_command(["sl", "shelve", "-m", "first stash"], cwd=sl_repo_with_commit)
        readme.write_text("second\n")
        run_command(["sl", "shelve", "-m", "second stash"], cwd=sl_repo_with_commit)

        # Show stash@{1} should work (first stash)
        result = run_gitsl(["stash", "show", "stash@{1}"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

    def test_stash_ref_invalid_index(self, sl_repo_with_commit: Path):
        """stash@{n} with invalid index returns error."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("content\n")
        run_command(["sl", "shelve"], cwd=sl_repo_with_commit)

        # stash@{10} doesn't exist
        result = run_gitsl(["stash", "show", "stash@{10}"], cwd=sl_repo_with_commit)
        assert result.exit_code == 1
        assert "does not exist" in result.stderr

    def test_stash_drop_with_ref(self, sl_repo_with_commit: Path):
        """git stash drop stash@{1} drops specific stash."""
        readme = sl_repo_with_commit / "README.md"

        # Create two stashes
        readme.write_text("first\n")
        run_command(["sl", "shelve", "-m", "first stash"], cwd=sl_repo_with_commit)
        readme.write_text("second\n")
        run_command(["sl", "shelve", "-m", "second stash"], cwd=sl_repo_with_commit)

        # Drop stash@{1} (first stash)
        result = run_gitsl(["stash", "drop", "stash@{1}"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        # First stash should be gone, second should remain
        shelves = run_command(["sl", "shelve", "--list"], cwd=sl_repo_with_commit)
        assert "first stash" not in shelves.stdout
        assert "second stash" in shelves.stdout


# ============================================================
# STSH-05: -p/--patch interactive mode
# ============================================================


class TestStashPatch:
    """STSH-05: -p/--patch translates to interactive mode."""

    def test_stash_patch_flag_accepted(self, sl_repo_with_commit: Path):
        """git stash -p flag is accepted (translates to -i)."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")

        # Note: Interactive mode will fail without TTY, but flag should be accepted
        # We just verify it doesn't error with "unknown flag"
        result = run_gitsl(["stash", "-p"], cwd=sl_repo_with_commit)
        # May fail due to no TTY, but shouldn't be "unknown flag"
        assert "unknown" not in result.stderr.lower()


# ============================================================
# STSH-06: -k/--keep-index warning
# ============================================================


class TestStashKeepIndex:
    """STSH-06: -k/--keep-index prints warning about no staging area."""

    def test_stash_keep_index_warning(self, sl_repo_with_commit: Path):
        """git stash -k prints warning."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")

        result = run_gitsl(["stash", "-k"], cwd=sl_repo_with_commit)
        # Should still work (stash the changes)
        assert result.exit_code == 0
        # But print warning
        assert "keep-index" in result.stderr.lower() or "staging" in result.stderr.lower()

    def test_stash_keep_index_long_warning(self, sl_repo_with_commit: Path):
        """git stash --keep-index prints warning."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")

        result = run_gitsl(["stash", "--keep-index"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        assert "staging" in result.stderr.lower()


# ============================================================
# STSH-07: -a/--all includes ignored files
# ============================================================


class TestStashAll:
    """STSH-07: -a/--all stashes all files including ignored."""

    def test_stash_all_includes_untracked(self, sl_repo_with_commit: Path):
        """git stash -a includes untracked files."""
        untracked = sl_repo_with_commit / "untracked.txt"
        untracked.write_text("untracked\n")

        result = run_gitsl(["stash", "-a"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        assert not untracked.exists()


# ============================================================
# STSH-08: -q/--quiet suppresses output
# ============================================================


class TestStashQuiet:
    """STSH-08: -q/--quiet suppresses output."""

    def test_stash_quiet(self, sl_repo_with_commit: Path):
        """git stash -q suppresses output."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")

        result = run_gitsl(["stash", "-q"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        # Output should be minimal or empty
        assert result.stdout.strip() == "" or len(result.stdout) < 50


# ============================================================
# STSH-09: stash push <pathspec>
# ============================================================


class TestStashPathspec:
    """STSH-09: stash push <pathspec> supports selective file stashing."""

    def test_stash_push_specific_file(self, sl_repo_with_commit: Path):
        """git stash push <file> stashes only that file."""
        # Modify two files
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")
        other = sl_repo_with_commit / "other.txt"
        other.write_text("other content\n")
        run_command(["sl", "add", "other.txt"], cwd=sl_repo_with_commit)

        # Stash only README.md
        result = run_gitsl(["stash", "push", "README.md"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        # README should be reverted, other.txt should still be added
        status = run_command(["sl", "status"], cwd=sl_repo_with_commit)
        assert "M README.md" not in status.stdout
        assert "other.txt" in status.stdout


# ============================================================
# STSH-10: stash branch <name>
# ============================================================


class TestStashBranch:
    """STSH-10: stash branch <name> creates branch from stash."""

    def test_stash_branch_creates_branch(self, sl_repo_with_commit: Path):
        """git stash branch <name> creates branch and applies stash."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("stashed content\n")
        run_command(["sl", "shelve", "-m", "for branch"], cwd=sl_repo_with_commit)

        result = run_gitsl(["stash", "branch", "from-stash"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        # Branch should exist
        bookmarks = run_command(["sl", "bookmark"], cwd=sl_repo_with_commit)
        assert "from-stash" in bookmarks.stdout

        # Changes should be applied
        assert readme.read_text() == "stashed content\n"

        # Stash should be dropped
        shelves = run_command(["sl", "shelve", "--list"], cwd=sl_repo_with_commit)
        assert "for branch" not in shelves.stdout

    def test_stash_branch_with_ref(self, sl_repo_with_commit: Path):
        """git stash branch <name> stash@{n} uses specific stash."""
        readme = sl_repo_with_commit / "README.md"

        # Create two stashes
        readme.write_text("first\n")
        run_command(["sl", "shelve", "-m", "first stash"], cwd=sl_repo_with_commit)
        readme.write_text("second\n")
        run_command(["sl", "shelve", "-m", "second stash"], cwd=sl_repo_with_commit)

        # Create branch from older stash
        result = run_gitsl(["stash", "branch", "from-first", "stash@{1}"],
                          cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        # Branch should exist
        bookmarks = run_command(["sl", "bookmark"], cwd=sl_repo_with_commit)
        assert "from-first" in bookmarks.stdout

    def test_stash_branch_no_name_error(self, sl_repo_with_commit: Path):
        """git stash branch without name returns error."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("content\n")
        run_command(["sl", "shelve"], cwd=sl_repo_with_commit)

        result = run_gitsl(["stash", "branch"], cwd=sl_repo_with_commit)
        assert result.exit_code == 1
        assert "requires" in result.stderr.lower() or "name" in result.stderr.lower()
```
  </action>
  <verify>
Run: `pytest tests/test_stash_flags.py -v` - all tests pass.
  </verify>
  <done>
tests/test_stash_flags.py covers STSH-01 through STSH-10 with comprehensive E2E tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create switch, restore, checkout flag tests</name>
  <files>tests/test_switch_flags.py, tests/test_restore_flags.py, tests/test_checkout_flags.py</files>
  <action>
**1. Create tests/test_switch_flags.py:**

```python
"""
E2E tests for git switch flags (CHKT-01, CHKT-02, CHKT-07, CHKT-08, CHKT-09).

Tests:
- CHKT-01: -c/--create creates and switches to new branch
- CHKT-02: -C/--force-create force creates branch
- CHKT-07: -d/--detach switches without activating bookmark
- CHKT-08: -f/--force/--discard-changes discards local changes
- CHKT-09: -m/--merge merges local changes during switch
"""

import shutil
from pathlib import Path

import pytest

from conftest import run_gitsl
from helpers.commands import run_command


sl_available = shutil.which("sl") is not None
pytestmark = [
    pytest.mark.skipif(not sl_available, reason="Sapling (sl) not installed"),
    pytest.mark.switch_flags,
]


# ============================================================
# CHKT-01: -c/--create (extended from existing tests)
# ============================================================


class TestSwitchCreate:
    """CHKT-01: switch -c/--create creates and switches to new branch."""

    def test_switch_create_and_goto(self, sl_repo_with_commit: Path):
        """git switch -c creates bookmark and switches to it."""
        result = run_gitsl(["switch", "-c", "new-branch"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        # Should be on new branch
        bookmarks = run_command(["sl", "bookmark"], cwd=sl_repo_with_commit)
        assert "* new-branch" in bookmarks.stdout or "new-branch" in bookmarks.stdout

    def test_switch_create_long_form(self, sl_repo_with_commit: Path):
        """git switch --create works same as -c."""
        result = run_gitsl(["switch", "--create", "long-branch"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        bookmarks = run_command(["sl", "bookmark"], cwd=sl_repo_with_commit)
        assert "long-branch" in bookmarks.stdout


# ============================================================
# CHKT-02: -C/--force-create
# ============================================================


class TestSwitchForceCreate:
    """CHKT-02: switch -C/--force-create force creates bookmark."""

    def test_switch_force_create_new(self, sl_repo_with_commit: Path):
        """git switch -C creates new bookmark."""
        result = run_gitsl(["switch", "-C", "force-branch"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        bookmarks = run_command(["sl", "bookmark"], cwd=sl_repo_with_commit)
        assert "force-branch" in bookmarks.stdout

    def test_switch_force_create_existing(self, sl_repo_with_commit: Path):
        """git switch -C updates existing bookmark."""
        # Create a bookmark
        run_command(["sl", "bookmark", "existing"], cwd=sl_repo_with_commit)

        # Make a new commit
        (sl_repo_with_commit / "new.txt").write_text("new\n")
        run_command(["sl", "add", "new.txt"], cwd=sl_repo_with_commit)
        run_command(["sl", "commit", "-m", "new commit"], cwd=sl_repo_with_commit)

        # Force create should succeed (update bookmark)
        result = run_gitsl(["switch", "-C", "existing"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0


# ============================================================
# CHKT-07: -d/--detach
# ============================================================


class TestSwitchDetach:
    """CHKT-07: switch -d/--detach switches without activating bookmark."""

    def test_switch_detach(self, sl_repo_with_commit: Path):
        """git switch -d switches to commit without active bookmark."""
        # Create and switch to a bookmark
        run_command(["sl", "bookmark", "test-branch"], cwd=sl_repo_with_commit)

        # Get current commit hash
        log = run_command(["sl", "log", "-l", "1", "--template", "{node|short}"],
                         cwd=sl_repo_with_commit)
        commit_hash = log.stdout.strip()

        # Switch with detach
        result = run_gitsl(["switch", "-d", commit_hash], cwd=sl_repo_with_commit)
        assert result.exit_code == 0


# ============================================================
# CHKT-08: -f/--force/--discard-changes
# ============================================================


class TestSwitchForce:
    """CHKT-08: switch -f discards local changes during switch."""

    def test_switch_force_discards_changes(self, sl_repo_with_commit: Path):
        """git switch -f discards uncommitted changes."""
        # Create a bookmark to switch to
        run_command(["sl", "bookmark", "target"], cwd=sl_repo_with_commit)
        run_command(["sl", "bookmark", "source"], cwd=sl_repo_with_commit)

        # Modify file
        readme = sl_repo_with_commit / "README.md"
        original = readme.read_text()
        readme.write_text("modified\n")

        # Switch with force should succeed and discard changes
        result = run_gitsl(["switch", "-f", "target"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        # Changes should be discarded
        assert readme.read_text() == original

    def test_switch_discard_changes_flag(self, sl_repo_with_commit: Path):
        """git switch --discard-changes works same as -f."""
        run_command(["sl", "bookmark", "target"], cwd=sl_repo_with_commit)

        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")

        result = run_gitsl(["switch", "--discard-changes", "target"],
                          cwd=sl_repo_with_commit)
        assert result.exit_code == 0


# ============================================================
# CHKT-09: -m/--merge
# ============================================================


class TestSwitchMerge:
    """CHKT-09: switch -m merges local changes during switch."""

    def test_switch_merge_flag_accepted(self, sl_repo_with_commit: Path):
        """git switch -m flag is accepted."""
        run_command(["sl", "bookmark", "target"], cwd=sl_repo_with_commit)

        result = run_gitsl(["switch", "-m", "target"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
```

**2. Create tests/test_restore_flags.py:**

```python
"""
E2E tests for git restore flags (CHKT-03, CHKT-04, CHKT-10, CHKT-11).

Tests:
- CHKT-03: --source/-s restores from specific commit
- CHKT-04: --staged/-S prints warning
- CHKT-10: -q/--quiet suppresses output
- CHKT-11: -W/--worktree is accepted (default behavior)
"""

import shutil
from pathlib import Path

import pytest

from conftest import run_gitsl
from helpers.commands import run_command


sl_available = shutil.which("sl") is not None
pytestmark = [
    pytest.mark.skipif(not sl_available, reason="Sapling (sl) not installed"),
    pytest.mark.restore_flags,
]


# ============================================================
# CHKT-03: --source/-s restores from specific commit
# ============================================================


class TestRestoreSource:
    """CHKT-03: restore --source/-s restores from specific commit."""

    def test_restore_source_short(self, sl_repo_with_commit: Path):
        """git restore -s <commit> <file> restores from specific commit."""
        readme = sl_repo_with_commit / "README.md"
        original = readme.read_text()

        # Make changes and commit
        readme.write_text("version 2\n")
        run_command(["sl", "commit", "-m", "version 2"], cwd=sl_repo_with_commit)

        # Restore from parent (previous commit)
        result = run_gitsl(["restore", "-s", ".^", "README.md"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        # File should have original content
        assert readme.read_text() == original

    def test_restore_source_long(self, sl_repo_with_commit: Path):
        """git restore --source=<commit> works."""
        readme = sl_repo_with_commit / "README.md"
        original = readme.read_text()

        readme.write_text("version 2\n")
        run_command(["sl", "commit", "-m", "version 2"], cwd=sl_repo_with_commit)

        result = run_gitsl(["restore", "--source=.^", "README.md"],
                          cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        assert readme.read_text() == original


# ============================================================
# CHKT-04: --staged/-S prints warning
# ============================================================


class TestRestoreStaged:
    """CHKT-04: restore --staged/-S prints warning about no staging area."""

    def test_restore_staged_warning(self, sl_repo_with_commit: Path):
        """git restore --staged prints warning."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")

        result = run_gitsl(["restore", "--staged", "README.md"],
                          cwd=sl_repo_with_commit)
        # Should still complete
        assert result.exit_code == 0
        # Should print warning about staging
        assert "staged" in result.stderr.lower() or "staging" in result.stderr.lower()

    def test_restore_S_warning(self, sl_repo_with_commit: Path):
        """git restore -S prints warning."""
        readme = sl_repo_with_commit / "README.md"
        readme.write_text("modified\n")

        result = run_gitsl(["restore", "-S", "README.md"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        assert "staging" in result.stderr.lower()


# ============================================================
# CHKT-10: -q/--quiet suppresses output
# ============================================================


class TestRestoreQuiet:
    """CHKT-10: restore -q/--quiet suppresses output."""

    def test_restore_quiet(self, sl_repo_with_commit: Path):
        """git restore -q suppresses output."""
        readme = sl_repo_with_commit / "README.md"
        original = readme.read_text()
        readme.write_text("modified\n")

        result = run_gitsl(["restore", "-q", "README.md"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        assert result.stdout.strip() == ""
        assert readme.read_text() == original


# ============================================================
# CHKT-11: -W/--worktree is accepted
# ============================================================


class TestRestoreWorktree:
    """CHKT-11: restore -W/--worktree is accepted (default behavior)."""

    def test_restore_worktree_accepted(self, sl_repo_with_commit: Path):
        """git restore -W flag is accepted."""
        readme = sl_repo_with_commit / "README.md"
        original = readme.read_text()
        readme.write_text("modified\n")

        result = run_gitsl(["restore", "-W", "README.md"], cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        assert readme.read_text() == original

    def test_restore_worktree_long_accepted(self, sl_repo_with_commit: Path):
        """git restore --worktree flag is accepted."""
        readme = sl_repo_with_commit / "README.md"
        original = readme.read_text()
        readme.write_text("modified\n")

        result = run_gitsl(["restore", "--worktree", "README.md"],
                          cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        assert readme.read_text() == original
```

**3. Create tests/test_checkout_flags.py:**

```python
"""
E2E tests for git checkout flags (CHKT-05, CHKT-06).

Tests:
- CHKT-05: --detach passes through
- CHKT-06: -t/--track is accepted with note
"""

import shutil
from pathlib import Path

import pytest

from conftest import run_gitsl
from helpers.commands import run_command


sl_available = shutil.which("sl") is not None
pytestmark = [
    pytest.mark.skipif(not sl_available, reason="Sapling (sl) not installed"),
    pytest.mark.checkout_flags,
]


# ============================================================
# CHKT-05: --detach
# ============================================================


class TestCheckoutDetach:
    """CHKT-05: checkout --detach switches to commit without branch."""

    def test_checkout_detach(self, sl_repo_with_commit: Path):
        """git checkout --detach <commit> switches without active bookmark."""
        # Get commit hash
        log = run_command(["sl", "log", "-l", "1", "--template", "{node|short}"],
                         cwd=sl_repo_with_commit)
        commit = log.stdout.strip()

        result = run_gitsl(["checkout", "--detach", commit], cwd=sl_repo_with_commit)
        assert result.exit_code == 0


# ============================================================
# CHKT-06: -t/--track
# ============================================================


class TestCheckoutTrack:
    """CHKT-06: checkout -t/--track is accepted with note."""

    def test_checkout_track_accepted(self, sl_repo_with_commit: Path):
        """git checkout -t -b <name> is accepted."""
        result = run_gitsl(["checkout", "-t", "-b", "tracked-branch"],
                          cwd=sl_repo_with_commit)
        assert result.exit_code == 0

        # Branch should be created
        bookmarks = run_command(["sl", "bookmark"], cwd=sl_repo_with_commit)
        assert "tracked-branch" in bookmarks.stdout

    def test_checkout_track_note(self, sl_repo_with_commit: Path):
        """git checkout --track prints note about limited emulation."""
        result = run_gitsl(["checkout", "--track", "-b", "another-tracked"],
                          cwd=sl_repo_with_commit)
        assert result.exit_code == 0
        # Should print note about tracking
        assert "track" in result.stderr.lower()
```
  </action>
  <verify>
Run: `pytest tests/test_switch_flags.py tests/test_restore_flags.py tests/test_checkout_flags.py -v` - all tests pass.
Run full test suite: `pytest tests/ -v --ignore=tests/test_readme.py` - no regressions.
  </verify>
  <done>
tests/test_switch_flags.py covers CHKT-01, CHKT-02, CHKT-07, CHKT-08, CHKT-09.
tests/test_restore_flags.py covers CHKT-03, CHKT-04, CHKT-10, CHKT-11.
tests/test_checkout_flags.py covers CHKT-05, CHKT-06.
All 21 requirements have test coverage.
  </done>
</task>

</tasks>

<verification>
1. All new test files run successfully: `pytest tests/test_stash_flags.py tests/test_switch_flags.py tests/test_restore_flags.py tests/test_checkout_flags.py -v`
2. Full test suite passes: `pytest tests/ -v --ignore=tests/test_readme.py`
3. All 21 requirements have at least one test
</verification>

<success_criteria>
- STSH-01 through STSH-10: Each has E2E test(s)
- CHKT-01 through CHKT-11: Each has E2E test(s)
- All tests pass in Sapling environment
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/26-stash-and-checkout-switch-restore-flags/26-02-SUMMARY.md`
</output>
